#!/usr/bin/env python3
from apps import config
import subprocess
import zipfile
import os
import time


class InstallationError(Exception): # Used to signify that installation / verification failed and we should roll back
    pass


def get_version(package, deb_file=False):
    """
    Get the version of a package or verify that it is installed
    Input:
        string package - Either the path to a debian package file, or the name of an installed package
        bool deb_file - set to True if inputting the path to a debian package file
    Output:
        string version - version of the package
            NoneType None denotes that the package is not installed.
    """
    if deb_file:
        return subprocess.check_output(['dpkg-deb', '-f', package, 'Version']).decode().rstrip()

    try:
        return subprocess.check_output(['dpkg-query', '--showformat=\'${Version}\'', '--show', package]).decode().strip('\'')
    except subprocess.CalledProcessError: # This happens if the package is not installed.
        return None


def unpack_zip(zip_path, unpack_path):
    """
    Unpacks the packages in the archive into NEW_DEB_PATH. Also extracts information about the packages.
    Input:
        string zip_path - path to the archive to be extracted (this should always be os.path.dirname(__file__), but it's a parameter for modularity)
        string unpack_path - path to where the packages should be placed
    Output:
        list package_list - list of packages inside the archive.
    """
    with zipfile.ZipFile(zip_path) as z:
        package_list = [item for item in z.namelist() if item.lower().endswith('.deb')]

        for package in package_list:
            z.extract(package, unpack_path)

    return package_list


def repack(package_dict, repack_path):
    """
    Repackage installed debian packages into .deb files
    Input:
        dict package_dict - a dictionary of packages to repack - Format: {package_name: version}
        string repack_path - path to where repackaged .deb files should be placed
    """
    if get_version('dpkg_repack') is None:
        subprocess.run(['apt-get', 'install', 'dpkg-repack'])

    for package_name, version in package_dict.items():
        subprocess.run(['dpkg-repack', package_name], cwd=repack_path)
        os.rename(f'{repack_path}/{package_name}_{version}_all.deb', f'{package_name}.deb')

    return


def verify_installation(packages, preinst_file_count, history_folder, timeout, check_frequency):
    """
    Verifies that packages are installed and working correctly.
    Input:
        list packages - new packages to be installed
        int preinst_file_count - Number of files that were in badtrack's history folder before installation.
        string history_folder - path to badtrack's history folder
        int timeout - how long to give badtrack to make it's first history file before rolling back.
        int check_frequency - how often to check the history folder for new files.
    """
    def verify_badtrack(preinst_file_count, history_folder, timeout, check_frequency):
        stop_time = time.time() + timeout
        while time.time() < stop_time: # Verify that badtrack is making files
            time.sleep(check_frequency)
            if len(os.listdir(history_folder)) > preinst_file_count:
                return True
        return False

    missing_packages = [package for package in packages if get_version(package) == None] # packages in new_packages that aren't installed

    if missing_packages:
        raise InstallationError(f'Packages were not installed: {missing_packages}')

    if not verify_badtrack(preinst_file_count, history_folder, timeout, check_frequency):
        raise InstallationError('No files were generated by badtrack within 1 minute')

    return


def rollback(new_packages, old_packages):
    """
    Rolls back the installation of packages.
    Input:
        list new_packages - installed packages to be replaced
        list old_packages - paths to old debian files to replace the installed versions
    """
    subprocess.run(['dpkg', '-r'] + list(new_packages))
    subprocess.run(['dpkg', '--skip-same-version', '-i'] + list(old_packages))
    return


def install_packages(packages):
    """
    Install debian packages from dictionary
    Input:
        list new_packages - new packages to be installed
    """
    install_command = ['dpkg', '--skip-same-version', '-i'] + packages
    subprocess.run(install_command, check=True)
    return


def add_path(path, packages):
    """
    Convert dictionary of packages into a list of paths to the debian files
    Input:
        string path - path to where the debian files are stored
        dict packages - dictionary of package names
    """
    return [f'{path}/{package}.deb' for package in packages.keys()]


def add_rollback_message(error):
    """
    Adds a message to the end of an error that notifies the user that the installation has been rolled back.
    """
    error.args = (error.args[0] + '\n\n    Installation has been rolled back',) + error.args[1:]
    return error


def make_directories(*directories):
    for folder in directories:
        os.makedirs(folder, exist_ok=True)
    return


def success_message(old_packages, new_packages):
    return '\n\nAll packages installed successfully. Changes:\n    ' + '\n    '.join(
        f"{package}: {old_packages.get(package,'None')} -> {version}"
        for package, version in new_packages.items()) 


def main(HISTORY_FOLDER, OLD_DEB_PATH, NEW_DEB_PATH):
    make_directories(HISTORY_FOLDER, NEW_DEB_PATH, OLD_DEB_PATH)

    # Extract archive, get list of packages to be installed
    _packages = unpack_zip(os.path.dirname(__file__), unpack_path=NEW_DEB_PATH)

    #              {Package_name: Version}
    NEW_PACKAGES = {os.path.splitext(item)[0]: get_version(f'{NEW_DEB_PATH}/{item}', deb_file=True)
                    for item in _packages}
    OLD_PACKAGES = {package: get_version(package)
                    for package in NEW_PACKAGES.keys()
                    if get_version(package) is not None}

    repack(OLD_PACKAGES, OLD_DEB_PATH)

    # Install packages
    preinst_file_count = len(os.listdir(HISTORY_FOLDER))
    try: 
        install_packages(add_path(NEW_DEB_PATH, NEW_PACKAGES))
        verify_installation(NEW_PACKAGES.keys(), preinst_file_count, HISTORY_FOLDER, timeout=20, check_frequency=5)

    # Rollback installation
    except Exception as error:
        rollback(NEW_PACKAGES.keys(), add_path(OLD_DEB_PATH, OLD_PACKAGES))
        error = add_rollback_message(error)
        raise error

    # Installation successful.
    print(success_message(OLD_PACKAGES, NEW_PACKAGES))
    return


if __name__ == '__main__':
    HISTORY_FOLDER = config['badtrack']['env']['HISTORY_FOLDER'] # Reads history path from apps.py
    UNPACK_PATH = os.environ.get("UNPACK_PATH", f'{os.getcwd()}/zip_unpack')
    NEW_DEB_PATH = f'{UNPACK_PATH}/new_debs'
    OLD_DEB_PATH = f'{UNPACK_PATH}/old_debs'

    main(HISTORY_FOLDER, NEW_DEB_PATH, OLD_DEB_PATH)
