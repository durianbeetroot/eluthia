#!/usr/bin/env python3
import subprocess
import zipfile
import os
import time

APP_PATH = os.getcwd() # We actually have to use this instead of abspath to get the correct value

HISTORY_PATH = '/var/lib/badtrack/history' #TODO: use environment variable.
UNPACK_PATH = f'{APP_PATH}/zip_unpack' #TODO: This could also be an environment variable?
NEW_DEB_PATH = f'{UNPACK_PATH}/new_debs'
OLD_DEB_PATH = f'{UNPACK_PATH}/old_debs'


def get_version(package_name):
    """
    Verifies that a package is installed, and get it's version.
    Input:
        string package_name - the name of the package that should be checked
    Output:
        string version - version of the package
            NoneType None denotes that the package is not installed.
    """
    try:
        # Get package version number by parsing dpkg -s.
        return str(subprocess.check_output(['dpkg', '-s', package_name]))\
                    .split('Version: ')[1]\
                     .split('\\n')[0]

    except subprocess.CalledProcessError: # This happens if the package is not installed. I could not find a way to check if packages are installed without causing an exception.
        return None


def unpack_zip(zip_path):
    """
    Unpacks the packages in the archive into NEW_DEB_PATH. Also extracts information about the packages.
    Input:
        string zip_path - path to the archive to be extracted (this should always be os.path.dirname(__file__), but it's a parameter for modularity)
    Output:
        dict new_packages - new packages to be installed and their versions. Format {package_name: version}
        dict old_packages - old packages to be replaced and their versions. Format: {package_name: version}
    """
    def parse_package_names(namelist):
        #TODO: Eventually, packages will be named with their version included. Once this change is made, this function will be properly implemented.
        packages = {}
        for item in namelist:
            if not item.endswith('.deb'): # Guard clause, makes us skip __main__.py or any other non-package files that might be added in future
                continue

            #TODO: Here we need to split the name into version and package name.
            version = None
            name = item[:-4] # removes .deb from package name

            packages[name] = version
        return packages

    with zipfile.ZipFile(zip_path) as z:

        new_packages = parse_package_names(z.namelist())
        old_packages = {package: get_version(package) for package in new_packages.keys() if get_version(package) is not None}

        for package in new_packages.keys():
            z.extract(f'{package}.deb', path=NEW_DEB_PATH) # Extract the packages to NEW_DEB_PATH

    return new_packages, old_packages #I'm not 100% sure if I want to return these from unpack_zip(), but I like that it means we only need to open the zip once.


def repack(package_name, version):
    subprocess.run(['dpkg-repack', package_name])
    repack_path = f'{APP_PATH}/{package_name}_{version}_all.deb' # Path to where dpkg-repack leaves the deb file.

    os.rename(repack_path, f'{OLD_DEB_PATH}/{package_name}.deb') # Move package from where dpkg-repack puts it to dedicated folder, and rename
    return


def verify_installation(new_packages, preinst_file_count, timeout, check_frequency): #TODO: finish
    """
    Verifies that packages are installed and working correctly.
    Input:
        dict new_packages - new packages to be installed and their versions. Format {package_name: version}
        int preinst_file_count - Number of files that were in badtrack's history folder before installation.
        int timeout - how long to give badtrack to make it's first history file before rolling back.
        int check_frequency - how often to check the history folder for new files.
    Output:
        bool - Whether the installation was successful.
        string error_message - If installation was not successful, contains the reason why installation was detected to be unsuccessful.
    """
    def verify_badtrack(preinst_file_count, timeout, check_frequency):
        while time.time() < timeout: # Verify that badtrack is making files
            time.sleep(check_frequency)
            if len(os.listdir(HISTORY_PATH)) > preinst_file_count:
                return True

        return False

    timeout = time.time() + timeout

    missing_packages = [package for package in new_packages.keys() if get_version(package) == None] # packages in new_packages that aren't installed
    if missing_packages:
            return False, f'Packages were not installed: {missing_packages}'

    if not verify_badtrack(preinst_file_count, timeout, check_frequency):
        return False, 'No files were generated by badtrack within 1 minute'

    return True, None


def rollback(new_packages, old_packages):
    """
    Rolls back the installation of packages.
    Input:
        dict new_packages - new packages to be installed and their versions. Format {package_name: version}
        dict old_packages - old packages to be replaced and their versions. Format {package_name: version}
    """
    subprocess.run(['dpkg', '-r'] + new_packages.keys()) # remove new packages
    reinstall_command = ['dpkg', '-E', '-i'] + [f'{OLD_DEB_PATH}/{package}.deb' for package in old_packages.keys()] # Necessary because of dependencies
    subprocess.run(reinstall_command)
    return


def main():
    os.makedirs(NEW_DEB_PATH, exist_ok=True)
    os.makedirs(OLD_DEB_PATH, exist_ok=True)

    # Extract archive, get packages and their versions
    new_packages, old_packages = unpack_zip(os.path.dirname(__file__)) # the variables are dictionaries {name: version}


    # Repack old packages
    subprocess.run(['apt-get', 'install', 'dpkg-repack'])
    for package_name, old_version in old_packages.items():
        repack(package_name, old_version)

    # Get current amount of badtrack history files (To verify that they increase after installation.)
    preinst_file_count = len(os.listdir(HISTORY_PATH))

    # Install new packages
    install_command = ['dpkg', '-E', '-i'] + [f'{NEW_DEB_PATH}/{package}.deb' for package in new_packages.keys()]
    subprocess.run(install_command)

    # Verify new packages
    install_successful, error_message = verify_installation(new_packages, preinst_file_count, timeout=60, check_frequency=5)
    if not install_successful:
        rollback(new_packages, old_packages)
        print(f"\n\n \033[91m Error: {error_message}. The installation has been rolled back.") # \033[91m makes text red.

    else: # Print information about package changes
        success_string = "\n\nAll packages installed successfully. Changes:"
        for package, version in new_packages.items():
            success_string += f"\n    {package}: {old_packages.get(package,'None')} -> (Not yet implemented)"
        print(success_string)

    return


if __name__ == '__main__':
    main()
