#!/usr/bin/env python3
from apps import config
import subprocess
import zipfile
import os
import time

HISTORY_PATH = config['badtrack']['env']['HISTORY_FOLDER'] # Reads history path from apps.py, so that the history path can only be changed in one place.
UNPACK_PATH = {os.environ.get("UNPACK_PATH", f'{os.getcwd()}/zip_unpack')}
NEW_DEB_PATH = f'{UNPACK_PATH}/new_debs'
OLD_DEB_PATH = f'{UNPACK_PATH}/old_debs'


def get_version(package, deb_file=False):
    """
    Get the version of a package or verify that it is installed
    Input:
        string package - Either the path to a debian package file, or the name of an installed package
        bool deb_file - set to True if inputting the path to a debian package file
    Output:
        string version - version of the package
            NoneType None denotes that the package is not installed.
    """
    if deb_file:
        return subprocess.check_output(['dpkg-deb', '-f', package, 'Version']).decode().rstrip()

    try:
        return subprocess.check_output(['dpkg-query', '--showformat=\'${Version}\'', '--show', package]).decode().strip('\'')
    except subprocess.CalledProcessError: # This happens if the package is not installed.
        return None
        


def unpack_zip(zip_path, unpack_path):
    """
    Unpacks the packages in the archive into NEW_DEB_PATH. Also extracts information about the packages.
    Input:
        string zip_path - path to the archive to be extracted (this should always be os.path.dirname(__file__), but it's a parameter for modularity)
        string unpack_path - path to where the packages should be placed
    Output:
        list package_list - list of packages inside the archive.
    """
    with zipfile.ZipFile(zip_path) as z:
        package_list = [item for item in z.namelist() if item.lower().endswith('.deb')]

        for package in package_list:
            z.extract(package, unpack_path)

    return package_list


def repack(package_dict, repack_path):
    """
    Repackage installed debian packages into .deb files
    Input:
        string repack_path - path to where repackaged .deb files should be placed
        dict package_dict - a dictionary of packages to repack - Format: {package_name: version}
    """
    if get_version('dpkg_repack') is None:
        subprocess.run(['apt-get', 'install', 'dpkg-repack'])

    for package_name, version in package_dict.items():
        subprocess.run(['dpkg-repack', package_name], cwd=repack_path)
        os.rename(f'{repack_path}/{package_name}_{version}_all.deb', f'{package_name}.deb')

    return


def verify_installation(new_packages, preinst_file_count, timeout, check_frequency): #TODO: finish
    """
    Verifies that packages are installed and working correctly.
    Input:
        dict new_packages - new packages to be installed and their versions. Format {package_name: version}
        int preinst_file_count - Number of files that were in badtrack's history folder before installation.
        int timeout - how long to give badtrack to make it's first history file before rolling back.
        int check_frequency - how often to check the history folder for new files.
    Output:
        bool - Whether the installation was successful.
        string error_message - If installation was not successful, contains the reason why installation was detected to be unsuccessful.
    """
    def verify_badtrack(preinst_file_count, timeout, check_frequency):
        while time.time() < timeout: # Verify that badtrack is making files
            time.sleep(check_frequency)
            if len(os.listdir(HISTORY_PATH)) > preinst_file_count:
                return True

        return False

    timeout = time.time() + timeout

    missing_packages = [package for package in new_packages.keys() if get_version(package) == None] # packages in new_packages that aren't installed
    if missing_packages:
            return False, f'Packages were not installed: {missing_packages}'

    if not verify_badtrack(preinst_file_count, timeout, check_frequency):
        return False, 'No files were generated by badtrack within 1 minute'

    return True, None


def rollback(new_packages, old_packages):
    """
    Rolls back the installation of packages.
    Input:
        list new_packages - installed packages to be replaced
        list old_packages - path to old debian files to replace the installed versions
    """
    subprocess.run(['dpkg', '-r'] + new_packages)
    subprocess.run(['dpkg', '--skip-same-version', '-i'] + old_packages)
    return


def install_packages(new_packages, timeout=60, check_frequency=5):
    """
    Install debian packages from dictionary
    Input:
        dict new_packages - new packages to be installed and their versions. Format {package_name: version}
        int timeout - how long to give badtrack to make it's first history file before rolling back.
        int check_frequency - how often to check the history folder for new files.
    Output:
        bool - Whether the installation was successful.
        string error_message - If installation was not successful, contains the reason why installation was detected to be unsuccessful.
    """
    preinst_file_count = len(os.listdir(HISTORY_PATH))
    install_command = ['dpkg', '--skip-same-version', '-i'] + [f'{NEW_DEB_PATH}/{package}.deb' for package in new_packages.keys()]
    try:
        subprocess.run(install_command, check=True)
    except subprocess.CalledProcessError:
        return False, 'dpkg failed to installed packages'

    return verify_installation(new_packages, preinst_file_count, timeout, check_frequency)


def main():
    os.makedirs(NEW_DEB_PATH, exist_ok=True)
    os.makedirs(OLD_DEB_PATH, exist_ok=True)

    # Extract archive, get list of packages to be installed
    _packages = unpack_zip(os.path.dirname(__file__), unpack_path=NEW_DEB_PATH)

    NEW_PACKAGES = {os.path.splitext(item)[0]: get_version(f'{NEW_DEB_PATH}/{item}', deb_file=True)
                    for item in _packages}
    OLD_PACKAGES = {package: get_version(package) for package in NEW_PACKAGES.keys() if get_version(package) is not None}

    # Repack old packages
    repack(OLD_PACKAGES, OLD_DEB_PATH)

    # Install packages, get information on whether installation
    install_successful, error_message = install_packages(NEW_PACKAGES, timeout=60, check_frequency=5)

    if not install_successful:
        rollback(NEW_PACKAGES.keys(), [f'{OLD_DEB_PATH}/{package}.deb' for package in OLD_PACKAGES.keys()])
        print(f"\n\n \033[91m Error: {error_message}. The installation has been rolled back.") # \033[91m makes text red.

    else: # Print information about package changes
        print('\n\nAll packages installed successfully. Changes:\n' + '\n    '.join(
            f"{package}: {OLD_PACKAGES.get(package,'None')} -> {version}"
            for package, version in NEW_PACKAGES.items()) )
    return


if __name__ == '__main__':
    main()
